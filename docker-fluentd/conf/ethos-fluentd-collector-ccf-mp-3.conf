<source>
  @type forward
  @id input_forward
  @label @mainstream
  bind 0.0.0.0
  port "#{ENV['FLUENTD_COLLECTOR_PORT_MP_3']}"
</source>

<label @mainstream>

  # Also, sets the tag based on the logging metadata.  If logging type is splunk, then the low/high volume setting is checked, and
  # the tag becomes a concatenation of the proper Splunk token, the volume setting, and the splunk setting.  Otherwise,
  # set the value to the log type set in the metadata (e.g., sumologic).  Failing that, set the tag to systemlog.
  # Example - applog.splunk.low.<token>, applog.sumologic.custom-source.custom-category.<collector-url>
  <match applog>
    @type record_reformer
    @id set_logging_tag_applog
    enable_ruby true
    tag ${if not record['ETHOS_LOGGING'].nil?; if record['ETHOS_LOGGING']['type'].to_s == "splunk"; record['ETHOS_LOGGING']['attributes']['volume'] == "low" ? ( "applog.splunk.low"  ) : ( "applog.splunk.high" ); elsif record['ETHOS_LOGGING']['type'].to_s == "sumologic"; "applog.sumologic." + record['ETHOS_LOGGING']['attributes']['source_name'].to_s + "." + record['ETHOS_LOGGING']['attributes']['source_category'].to_s + "." + record['ETHOS_LOGGING']['attributes']['collector_url'].to_s; end; else "systemlog"; end}
  </match>

  <filter applog.splunk.**>
    @type record_transformer
    @id format_for_splunk
    enable_ruby true
    renew_record true
    auto_typecast true
    <record>
      timestamp ${record['timestamp']}    
      host ${record['source_host']}
      index ${record['ETHOS_LOGGING']['attributes']['index']}
      source ${record['CONTAINER_IMAGE']},${record['CONTAINER_NAME']},${record["CONTAINER_ID"]}
      sourcetype ${record['ETHOS_LOGGING']['attributes']['source_type']}
      message ${record['message']}
    </record>
  </filter>

  <match systemlog>
    @type rewrite_tag_filter
    @id split_kernel_system_logs
    rewriterule1 _TRANSPORT kernel systemlog.kernel
    rewriterule2 _TRANSPORT .+ systemlog.systemd
  </match>

  # Same as the above, only for system logs, using the FLUENTD_SYSTEM_LOG_TYPE environment variable.
  <match systemlog.systemd>
    @type record_reformer
    @id set_logging_tag_systemlog
    enable_ruby true
    auto_typecast true
    tag ${if not ENV['FLUENTD_SYSTEM_LOG_TYPE'].nil?; if ENV['FLUENTD_SYSTEM_LOG_TYPE'].to_s == "splunk"; ENV['FLUENTD_SYSTEM_LOG_SPLUNK_VOLUME'].to_s == "low" ? ( "systemlog.splunk.low" ) : ( "systemlog.splunk.high" ); elsif ENV['FLUENTD_SYSTEM_LOG_TYPE'].to_s == "sumologic"; "systemlog.sumologic." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_SOURCENAME'].to_s + "." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_SOURCECATEGORY'].to_s + "." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_COLLECTORURL'].to_s; end; else "logging.disabled"; end}
    <record>
      host ${record['source_host']}
      source ${record['_SYSTEMD_UNIT']}
      message ${record['MESSAGE'].to_s.gsub(/((?:(?:4\d{3})|(?:5[1-5]\d{2})|6(?:011|5[0-9]{2}))(?:-?|\040?)(?:\d{4}(?:-?|\040?)){3}|(?:3[4,7]\d{2})(?:-?|\040?)\d{6}(?:-?|\040?)\d{5})/, "<POSSIBLE_CREDIT_CARD_NUMBER>").gsub(/\s*-e\s+(?<param>\w+)=(?<value>\S+)/, " -e \\k<param>=xxxxx").gsub(/(?<param>[A-Z_]+)\s*->\s*(?<value>\S+)/, "\\k<param> -> xxxxx").gsub(/EnvironmentVariable\((?<param>[A-Z_]+)\s*\,\s*(?<value>\S+)\)/, "EnvironmentVariable\(\\k<param>,xxxxx\)")}
    </record>
  </match>

  <match systemlog.kernel>
    @type record_reformer
    @id set_logging_tag_systemlog_kernel
    enable_ruby true
    auto_typecast true
    tag ${if not ENV['FLUENTD_SYSTEM_LOG_TYPE'].nil?; if ENV['FLUENTD_SYSTEM_LOG_TYPE'].to_s == "splunk"; ENV['FLUENTD_SYSTEM_LOG_SPLUNK_VOLUME'].to_s == "low" ? ( "systemlog.splunk.low" ) : ( "systemlog.splunk.high" ); elsif ENV['FLUENTD_SYSTEM_LOG_TYPE'].to_s == "sumologic"; "systemlog.sumologic." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_SOURCENAME'].to_s + "." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_SOURCECATEGORY'].to_s + "." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_COLLECTORURL'].to_s; end; else "logging.disabled"; end}
    <record>
      host ${record['source_host']}
      source ${record['SYSLOG_IDENTIFIER']}
      message ${record['MESSAGE'].to_s.gsub(/((?:(?:4\d{3})|(?:5[1-5]\d{2})|6(?:011|5[0-9]{2}))(?:-?|\040?)(?:\d{4}(?:-?|\040?)){3}|(?:3[4,7]\d{2})(?:-?|\040?)\d{6}(?:-?|\040?)\d{5})/, "<POSSIBLE_CREDIT_CARD_NUMBER>").gsub(/\s*-e\s+(?<param>\w+)=(?<value>\S+)/, " -e \\k<param>=xxxxx").gsub(/(?<param>[A-Z_]+)\s*->\s*(?<value>\S+)/, "\\k<param> -> xxxxx").gsub(/EnvironmentVariable\((?<param>[A-Z_]+)\s*\,\s*(?<value>\S+)\)/, "EnvironmentVariable\(\\k<param>,xxxxx\)")}
    </record>
  </match>

  # Handle tagging for syslog events, sending them as system logs
  <match systemlog.syslog.**>
    @type record_reformer
    @id set_logging_tag_syslog
    enable_ruby true
    tag ${if not ENV['FLUENTD_SYSTEM_LOG_TYPE'].nil?; if ENV['FLUENTD_SYSTEM_LOG_TYPE'].to_s == "splunk"; ENV['FLUENTD_SYSTEM_LOG_SPLUNK_VOLUME'].to_s == "low" ? ( "systemlog.splunk.low" ) : ( "systemlog.splunk.high" ); elsif ENV['FLUENTD_SYSTEM_LOG_TYPE'].to_s == "sumologic"; "systemlog.sumologic." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_SOURCENAME'].to_s + "." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_SOURCECATEGORY'].to_s + "." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_COLLECTORURL'].to_s; end; else "logging.disabled"; end}
  </match>

  # Handle tagging for Mesos executor logs, sending them as system logs
  <match executorlog>
    @type record_reformer
    @id set_logging_tag_executorlog
    enable_ruby true
    auto_typecast true
    tag ${if not ENV['FLUENTD_MESOS_LOG_TYPE'].nil?; if ENV['FLUENTD_MESOS_LOG_TYPE'].to_s == "splunk"; ENV['FLUENTD_MESOS_LOG_SPLUNK_VOLUME'].to_s == "low" ? ( "executorlog.splunk.low"  ) : ( "executorlog.splunk.high" ); elsif ENV['FLUENTD_MESOS_LOG_TYPE'].to_s == "sumologic"; "executorlog.sumologic." + ENV['FLUENTD_MESOS_LOG_SUMOLOGIC_SOURCENAME'].to_s + "." + ENV['FLUENTD_MESOS_LOG_SUMOLOGIC_SOURCECATEGORY'].to_s + "." + ENV['FLUENTD_MESOS_LOG_SUMOLOGIC_COLLECTORURL'].to_s; end; else "logging.disabled"; end}
    <record>
      host ${record['source_host']}
      message ${record['message'].to_s.gsub(/((?:(?:4\d{3})|(?:5[1-5]\d{2})|6(?:011|5[0-9]{2}))(?:-?|\040?)(?:\d{4}(?:-?|\040?)){3}|(?:3[4,7]\d{2})(?:-?|\040?)\d{6}(?:-?|\040?)\d{5})/, "<POSSIBLE_CREDIT_CARD_NUMBER>").gsub(/\s*-e\s+(?<param>\w+)=(?<value>\S+)/, " -e \\k<param>=xxxxx").gsub(/(?<param>[A-Z_]+)\s*->\s*(?<value>\S+)/, "\\k<param> -> xxxxx").gsub(/EnvironmentVariable\((?<param>[A-Z_]+)\s*\,\s*(?<value>\S+)\)/, "EnvironmentVariable\(\\k<param>,xxxxx\)")}
      source ${record['file_path'].split('/')[10]}
    </record>
  </match>

  # Discard logs that don't have a sender configured (splunk, sumologic, etc.)
  <match logging.disabled>
    @type null
  </match>

  <match applog.splunk.high>
    @type copy
    <store>
      @type splunk-http-eventcollector
      @id applog_to_splunk
      server "#{ENV['FLUENTD_SPLUNK_HEC_SERVER']}"
      verify "#{ENV['FLUENTD_SPLUNK_HEC_SSL_VERIFY']}"
      token "#{ENV['FLUENTD_SPLUNK_HEC_TOKEN']}"
      time_key "#{ENV['FLUENTD_SPLUNK_HEC_TIME_KEY']}"
      all_items "#{ENV['FLUENTD_SPLUNK_HEC_ALL_ITEMS']}"
      post_retry_max "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_MAX']}"
      post_retry_interval "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_INTERVAL']}"
      protocol "#{ENV['FLUENTD_SPLUNK_HEC_PROTOCOL']}"
      batch_size_limit "#{ENV['FLUENTD_SPLUNK_HEC_BATCH_SIZE_LIMIT']}"
      coerce_to_utf8 "#{ENV['FLUENTD_SPLUNK_HEC_COERCE_TO_UTF8']}"
      non_utf8_replacement_string "#{ENV['FLUENTD_SPLUNK_HEC_NON_UTF8_REPLACEMENT_STRING']}"

      buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
      buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/3/applog.splunk.high/"
      buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
      buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
      flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
      flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
      retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_WAIT']}"
      max_retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_MAX_RETRY_WAIT']}"
      retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
      disable_retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_DISABLE_RETRY_LIMIT']}"
      num_threads "#{ENV['FLUENTD_SPLUNK_HEC_NUM_THREADS']}"

      host ${record["host"]}
      index ${record["index"]}
      source ${record["source"]}
      sourcetype ${record["sourcetype"]}
      <secondary>
        @type s3
        s3_bucket "#{ENV['FLUENTD_AWS_S3_BUCKET']}"
        s3_region us-east-1
        path "#{ENV['FLUENTD_AWS_S3_BUCKET_PATH']}"
        s3_object_key_format "%{path}collector/3/applog/splunk/high/#{ENV['HOST']}_%{time_slice}_%{index}.%{file_extension}"
        store_as text
        buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
        buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/3/s3/applog.splunk.high/"
        buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
        buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
        flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
        flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
        retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
        <assume_role_credentials>
         role_arn "#{ENV['FLUENTD_AWS_IAM_ROLE']}"
         role_session_name fluentd-s3
        </assume_role_credentials>
      </secondary>
    </store>
    <store>
      @type flowcounter
      @id applog_high_metrics
      @label @counts
      tag fluentd.apploghigh.metrics
      aggregate all
      count_keys *
      unit minute
    </store>
  </match>

  <match applog.splunk.low>
    @type copy
    <store>
      @type splunk-http-eventcollector
      @id applog_to_lvc_splunk
      server "#{ENV['FLUENTD_SPLUNK_HEC_LVC_SERVER']}"
      verify "#{ENV['FLUENTD_SPLUNK_HEC_LVC_SSL_VERIFY']}"
      token "#{ENV['FLUENTD_SPLUNK_HEC_LVC_TOKEN']}"
      time_key "#{ENV['FLUENTD_SPLUNK_HEC_TIME_KEY']}"
      all_items "#{ENV['FLUENTD_SPLUNK_HEC_ALL_ITEMS']}"
      post_retry_max "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_MAX']}"
      post_retry_interval "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_INTERVAL']}"
      protocol "#{ENV['FLUENTD_SPLUNK_HEC_LVC_PROTOCOL']}"
      batch_size_limit "#{ENV['FLUENTD_SPLUNK_HEC_BATCH_SIZE_LIMIT']}"
      coerce_to_utf8 "#{ENV['FLUENTD_SPLUNK_HEC_COERCE_TO_UTF8']}"
      non_utf8_replacement_string "#{ENV['FLUENTD_SPLUNK_HEC_NON_UTF8_REPLACEMENT_STRING']}"

      buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
      buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/3/applog.splunk.low/"
      buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
      buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
      flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
      flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
      retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_WAIT']}"
      max_retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_MAX_RETRY_WAIT']}"
      retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
      disable_retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_DISABLE_RETRY_LIMIT']}"
      num_threads "#{ENV['FLUENTD_SPLUNK_HEC_NUM_THREADS']}"

      host ${record["host"]}
      index ${record["index"]}
      source ${record["source"]}
      sourcetype ${record["sourcetype"]}
      <secondary>
        @type s3
        s3_bucket "#{ENV['FLUENTD_AWS_S3_BUCKET']}"
        s3_region us-east-1
        path "#{ENV['FLUENTD_AWS_S3_BUCKET_PATH']}"
        s3_object_key_format "%{path}collector/3/applog/splunk/low/#{ENV['HOST']}_%{time_slice}_%{index}.%{file_extension}"
        store_as text
        buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
        buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/3/s3/applog.splunk.low/"
        buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
        buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
        flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
        flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
        retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
        <assume_role_credentials>
         role_arn "#{ENV['FLUENTD_AWS_IAM_ROLE']}"
         role_session_name fluentd-s3
        </assume_role_credentials>
      </secondary>
    </store>
    <store>
      @type flowcounter
      @id applog_metrics
      @label @counts
      tag fluentd.apploglow.metrics
      aggregate all
      count_keys *
      unit minute
    </store>
  </match>

  <match systemlog.splunk.*>
    @type copy
    <store>
      @type splunk-http-eventcollector
      @id systemlog_to_splunk
      server "#{ENV['FLUENTD_SPLUNK_HEC_SERVER']}"
      verify "#{ENV['FLUENTD_SPLUNK_HEC_SSL_VERIFY']}"
      token "#{ENV['FLUENTD_SPLUNK_HEC_TOKEN']}"
      time_key "#{ENV['FLUENTD_SPLUNK_HEC_TIME_KEY']}"
      all_items "#{ENV['FLUENTD_SPLUNK_HEC_ALL_ITEMS']}"
      post_retry_max "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_MAX']}"
      post_retry_interval "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_INTERVAL']}"
      protocol "#{ENV['FLUENTD_SPLUNK_HEC_PROTOCOL']}"
      batch_size_limit "#{ENV['FLUENTD_SPLUNK_HEC_BATCH_SIZE_LIMIT']}"
      coerce_to_utf8 "#{ENV['FLUENTD_SPLUNK_HEC_COERCE_TO_UTF8']}"
      non_utf8_replacement_string "#{ENV['FLUENTD_SPLUNK_HEC_NON_UTF8_REPLACEMENT_STRING']}"

      buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
      buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/3/systemlog.splunk/"
      buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
      buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
      flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
      flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
      retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_WAIT']}"
      max_retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_MAX_RETRY_WAIT']}"
      retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
      disable_retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_DISABLE_RETRY_LIMIT']}"
      num_threads "#{ENV['FLUENTD_SPLUNK_HEC_NUM_THREADS']}"

      host ${record["host"]}
      index "#{ENV['FLUENTD_SYSTEM_LOG_SPLUNK_INDEX']}"
      source ${record["source"]}
      sourcetype "#{ENV['FLUENTD_SYSTEM_LOG_SPLUNK_SOURCETYPE']}"
      <secondary>
        @type s3
        s3_bucket "#{ENV['FLUENTD_AWS_S3_BUCKET']}"
        s3_region us-east-1
        path "#{ENV['FLUENTD_AWS_S3_BUCKET_PATH']}"
        s3_object_key_format "%{path}collector/3/systemlog/#{ENV['HOST']}_%{time_slice}_%{index}.%{file_extension}"
        store_as text
        buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
        buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/3/s3/systemlog.splunk/"
        buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
        buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
        flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
        flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
        retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
        <assume_role_credentials>
         role_arn "#{ENV['FLUENTD_AWS_IAM_ROLE']}"
         role_session_name fluentd-s3
        </assume_role_credentials>
      </secondary>
    </store>
    <store>
      @type flowcounter
      @id systemlog_metrics
      @label @counts
      tag fluentd.systemlog.metrics
      aggregate all
      count_keys message
      unit minute
    </store>
    <store>
      @type rewrite_tag_filter
      rewriterule1 message .+ splunkes.${tag}
    </store>
  </match>

  <match executorlog.splunk.*>
    @type copy
    <store>
      @type splunk-http-eventcollector
      @id executorlog_to_splunk
      server "#{ENV['FLUENTD_SPLUNK_HEC_SERVER']}"
      verify "#{ENV['FLUENTD_SPLUNK_HEC_SSL_VERIFY']}"
      token "#{ENV['FLUENTD_SPLUNK_HEC_TOKEN']}"
      time_key "#{ENV['FLUENTD_SPLUNK_HEC_TIME_KEY']}"
      all_items "#{ENV['FLUENTD_SPLUNK_HEC_ALL_ITEMS']}"
      post_retry_max "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_MAX']}"
      post_retry_interval "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_INTERVAL']}"
      protocol "#{ENV['FLUENTD_SPLUNK_HEC_PROTOCOL']}"
      batch_size_limit "#{ENV['FLUENTD_SPLUNK_HEC_BATCH_SIZE_LIMIT']}"
      coerce_to_utf8 "#{ENV['FLUENTD_SPLUNK_HEC_COERCE_TO_UTF8']}"
      non_utf8_replacement_string "#{ENV['FLUENTD_SPLUNK_HEC_NON_UTF8_REPLACEMENT_STRING']}"

      buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
      buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/3/executorlog.splunk/"
      buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
      buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
      flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
      flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
      retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_WAIT']}"
      max_retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_MAX_RETRY_WAIT']}"
      retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
      disable_retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_DISABLE_RETRY_LIMIT']}"
      num_threads "#{ENV['FLUENTD_SPLUNK_HEC_NUM_THREADS']}"

      host ${record["host"]}
      index "#{ENV['FLUENTD_MESOS_LOG_SPLUNK_INDEX']}"
      source ${record["source"]}
      sourcetype "#{ENV['FLUENTD_MESOS_LOG_SPLUNK_SOURCETYPE']}"
      <secondary>
        @type s3
        s3_bucket "#{ENV['FLUENTD_AWS_S3_BUCKET']}"
        s3_region us-east-1
        path "#{ENV['FLUENTD_AWS_S3_BUCKET_PATH']}"
        s3_object_key_format "%{path}collector/3/executorlog/#{ENV['HOST']}_%{time_slice}_%{index}.%{file_extension}"
        store_as text
        buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
        buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/3/s3/executorlog.splunk/"
        buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
        buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
        flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
        flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
        retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
        <assume_role_credentials>
         role_arn "#{ENV['FLUENTD_AWS_IAM_ROLE']}"
         role_session_name fluentd-s3
        </assume_role_credentials>
      </secondary>
    </store>
    <store>
      @type flowcounter
      @id executorlog_metrics
      @label @counts
      tag fluentd.executorlog.metrics
      aggregate all
      count_keys message
      unit minute
    </store>
    <store>
      @type rewrite_tag_filter
      rewriterule1 message .+ splunkes.${tag}
    </store>
  </match>

  <match splunkes.**>
    @type copy
    <store>
      @type splunk-http-eventcollector
      @id systemlog_to_splunkes
        server "#{ENV['FLUENTD_SPLUNKES_HEC_SERVER']}"
        verify "#{ENV['FLUENTD_SPLUNKES_HEC_SSL_VERIFY']}"
        token "#{ENV['FLUENTD_SPLUNKES_HEC_TOKEN']}"
        time_key "#{ENV['FLUENTD_SPLUNK_HEC_TIME_KEY']}"
        all_items "#{ENV['FLUENTD_SPLUNK_HEC_ALL_ITEMS']}"
        post_retry_max "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_MAX']}"
        post_retry_interval "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_INTERVAL']}"
        protocol "#{ENV['FLUENTD_SPLUNKES_HEC_PROTOCOL']}"
        batch_size_limit "#{ENV['FLUENTD_SPLUNK_HEC_BATCH_SIZE_LIMIT']}"
        coerce_to_utf8 "#{ENV['FLUENTD_SPLUNK_HEC_COERCE_TO_UTF8']}"
        non_utf8_replacement_string "#{ENV['FLUENTD_SPLUNK_HEC_NON_UTF8_REPLACEMENT_STRING']}"

        buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
        buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/3/splunkes/"
        buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
        buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
        flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
        flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
        retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_WAIT']}"
        max_retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_MAX_RETRY_WAIT']}"
        retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
        disable_retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_DISABLE_RETRY_LIMIT']}"
        num_threads "#{ENV['FLUENTD_SPLUNK_HEC_NUM_THREADS']}"

        host ${record["host"]}
        index "#{ENV['FLUENTD_SYSTEM_LOG_SPLUNKES_INDEX']}"
        source ${record["source"]}
        sourcetype "#{ENV['FLUENTD_SYSTEM_LOG_SPLUNKES_SOURCETYPE']}"
        <secondary>
          @type s3
          s3_bucket "#{ENV['FLUENTD_AWS_S3_BUCKET']}"
          s3_region us-east-1
          path "#{ENV['FLUENTD_AWS_S3_BUCKET_PATH']}"
          s3_object_key_format "%{path}collector/3/splunkes/#{ENV['HOST']}_%{time_slice}_%{index}.%{file_extension}"
          store_as text
          buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
          buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/3/s3/splunkes/"
          buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
          buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
          flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
          flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
          retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
          <assume_role_credentials>
           role_arn "#{ENV['FLUENTD_AWS_IAM_ROLE']}"
           role_session_name fluentd-s3
          </assume_role_credentials>
        </secondary>
    </store>
    <store>
      @type flowcounter
      @id systemloges_metrics
      @label @counts
      tag fluentd.splunkes.metrics
      aggregate all
      count_keys message
      unit minute
    </store>
  </match>

</label>

<label @counts>
  <match fluentd.*.metrics>
    @type stdout
  </match>
</label>
