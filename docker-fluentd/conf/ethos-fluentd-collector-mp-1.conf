<source>
  type monitor_agent
  bind 0.0.0.0
  port "#{ENV['FLUENTD_MONITOR_PORT']}"
</source>

<source>
  @type forward
  @id input_forward
  @label @mainstream
  bind 0.0.0.0
  port "#{ENV['FLUENTD_COLLECTOR_PORT_MP_1']}"
</source>

<source>
  @type systemd
  @id ingest_from_journald
  @label @mainstream
  path "#{ENV['FLUENTD_SYSTEMD_PATH']}"
  filters "#{ENV['FLUENTD_SYSTEMD_FILTERS']}"
  pos_file "#{ENV['FLUENTD_SYSTEMD_POS_FILE']}"
  read_from_head "#{ENV['FLUENTD_SYSTEMD_READ_FROM_HEAD']}"
  strip_underscores "#{ENV['FLUENTD_SYSTEMD_STRIP_UNDERSCORES']}"
  tag collector.systemlog
</source>

<source>
  @type tail
  @id ingest_from_tail
  @label @mainstream
  read_from_head "#{ENV['FLUENTD_TAIL_READ_FROM_HEAD']}"
  refresh_interval "#{ENV['FLUENTD_TAIL_REFRESH_INTERVAL']}"
  enable_watch_timer "#{ENV['FLUENTD_TAIL_ENABLE_WATCH_TIMER']}"
  rotate_wait "#{ENV['FLUENTD_TAIL_ROTATE_WAIT']}"
  path "#{ENV['FLUENTD_TAIL_EXECUTOR_LOG_PATH']}/**/std*"
  exclude_path "#{ENV['FLUENTD_TAIL_EXECUTOR_LOG_PATH']}/**/std*.*"
  pos_file "#{ENV['FLUENTD_TAIL_EXECUTOR_LOG_PATH']}/fluentd.pos"
  path_key "#{ENV['FLUENTD_TAIL_PATH_KEY']}"
  format none
  tag collector.executorlog
</source>

<label @mainstream>

  # Discard all log records that have an empty or missing message field
  # Drop logs with blank lines
  <filter collector.executorlog>
    @type grep
    @id blank_line_filter
    regexp1 message \S+
  </filter>
  <filter collector.systemlog>
    @type grep
    @id blank_line_filter2
    regexp1 MESSAGE \S+
  </filter>

  # Discard all executor logs except for those specific to the ETHOS cluster
  <filter collector.executorlog>
    @type grep
    @id filter_mesos_executor_log
    regexp1 file_path executors\/(agentfill|apigateway|aqua-agent|aqua-ethos-setup|aqua-gateway|aqua-web|booster|capcom|docker-cleanup|dsn|ecr-login|etcd|ethos-datadog|ethos-fluentd|ethos-splunkforwarder|feature-flipper-cache|flight-director|jenkins|iam-role-iptables|iam-role-proxy|klam-ssh|mercury|moonbeam|moonmaker|orca|prometheus|sidekick|skopos)
  </filter>

  # Set the timestamp and source_host field for local records
  # and lop off the collector prefix on the tag
  <match collector.**>
    @type record_reformer
    @id set_logging_host
    tag ${tag_suffix[1]}
    <record>
      timestamp ${(Time.now.to_f).to_s}
      source_host "#{ENV['MESOS_CLUSTER']},#{ENV['ethos_role']},#{ENV['zone']},#{ENV['HOST']}"
    </record>
  </match>

  # Also, sets the tag based on the logging metadata.  If logging type is splunk, then the low/high volume setting is checked, and
  # the tag becomes a concatenation of the proper Splunk token, the volume setting, and the splunk setting.  Otherwise,
  # set the value to the log type set in the metadata (e.g., sumologic).  Failing that, set the tag to systemlog.
  # Example - applog.splunk.low.<token>, applog.sumologic.custom-source.custom-category.<collector-url>
  <match applog>
    @type record_reformer
    @id set_logging_tag_applog
    enable_ruby true
    tag ${if not record['ETHOS_LOGGING'].nil?; if record['ETHOS_LOGGING']['type'].to_s == "splunk"; record['ETHOS_LOGGING']['attributes']['volume'] == "low" ? ( "applog.splunk.low"  ) : ( "applog.splunk.high" ); elsif record['ETHOS_LOGGING']['type'].to_s == "sumologic"; "applog.sumologic." + record['ETHOS_LOGGING']['attributes']['source_name'].to_s + "." + record['ETHOS_LOGGING']['attributes']['source_category'].to_s + "." + record['ETHOS_LOGGING']['attributes']['collector_url'].to_s; end; else "systemlog"; end}
  </match>

  <filter applog.splunk.**>
    @type record_transformer
    @id format_for_splunk
    enable_ruby true
    renew_record true
    auto_typecast true
    <record>
      timestamp ${record['timestamp']}
      host ${record['source_host']}
      index ${record['ETHOS_LOGGING']['attributes']['index']}
      source ${record['CONTAINER_IMAGE']},${record['CONTAINER_NAME']},${record["CONTAINER_ID"]}
      sourcetype ${record['ETHOS_LOGGING']['attributes']['source_type']}
      message ${record['message']}
    </record>
  </filter>

  <match systemlog>
    @type rewrite_tag_filter
    @id split_kernel_system_logs
    rewriterule1 _TRANSPORT kernel systemlog.kernel
    rewriterule2 _TRANSPORT .+ systemlog.systemd
  </match>

  # Same as the above, only for system logs, using the FLUENTD_SYSTEM_LOG_TYPE environment variable.
  <match systemlog.systemd>
    @type record_reformer
    @id set_logging_tag_systemlog
    enable_ruby true
    auto_typecast true
    tag ${if not ENV['FLUENTD_SYSTEM_LOG_TYPE'].nil?; if ENV['FLUENTD_SYSTEM_LOG_TYPE'].to_s == "splunk"; ENV['FLUENTD_SYSTEM_LOG_SPLUNK_VOLUME'].to_s == "low" ? ( "systemlog.splunk.low" ) : ( "systemlog.splunk.high" ); elsif ENV['FLUENTD_SYSTEM_LOG_TYPE'].to_s == "sumologic"; "systemlog.sumologic." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_SOURCENAME'].to_s + "." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_SOURCECATEGORY'].to_s + "." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_COLLECTORURL'].to_s; end; else "logging.disabled"; end}
    <record>
      host ${record['source_host']}
      source ${record['_SYSTEMD_UNIT']}
      message ${record['MESSAGE'].to_s.gsub(/((?:(?:4\d{3})|(?:5[1-5]\d{2})|6(?:011|5[0-9]{2}))(?:-?|\040?)(?:\d{4}(?:-?|\040?)){3}|(?:3[4,7]\d{2})(?:-?|\040?)\d{6}(?:-?|\040?)\d{5})/, "<POSSIBLE_CREDIT_CARD_NUMBER>").gsub(/\s*-e\s+(?<param>\w+)=(?<value>\S+)/, " -e \\k<param>=xxxxx").gsub(/(?<param>[A-Z_]+)\s*->\s*(?<value>\S+)/, "\\k<param> -> xxxxx").gsub(/EnvironmentVariable\((?<param>[A-Z_]+)\s*\,\s*(?<value>\S+)\)/, "EnvironmentVariable\(\\k<param>,xxxxx\)")}
    </record>
  </match>

  <match systemlog.kernel>
    @type record_reformer
    @id set_logging_tag_systemlog_kernel
    enable_ruby true
    auto_typecast true
    tag ${if not ENV['FLUENTD_SYSTEM_LOG_TYPE'].nil?; if ENV['FLUENTD_SYSTEM_LOG_TYPE'].to_s == "splunk"; ENV['FLUENTD_SYSTEM_LOG_SPLUNK_VOLUME'].to_s == "low" ? ( "systemlog.splunk.low" ) : ( "systemlog.splunk.high" ); elsif ENV['FLUENTD_SYSTEM_LOG_TYPE'].to_s == "sumologic"; "systemlog.sumologic." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_SOURCENAME'].to_s + "." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_SOURCECATEGORY'].to_s + "." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_COLLECTORURL'].to_s; end; else "logging.disabled"; end}
    <record>
      host ${record['source_host']}
      source ${record['SYSLOG_IDENTIFIER']}
      message ${record['MESSAGE'].to_s.gsub(/((?:(?:4\d{3})|(?:5[1-5]\d{2})|6(?:011|5[0-9]{2}))(?:-?|\040?)(?:\d{4}(?:-?|\040?)){3}|(?:3[4,7]\d{2})(?:-?|\040?)\d{6}(?:-?|\040?)\d{5})/, "<POSSIBLE_CREDIT_CARD_NUMBER>").gsub(/\s*-e\s+(?<param>\w+)=(?<value>\S+)/, " -e \\k<param>=xxxxx").gsub(/(?<param>[A-Z_]+)\s*->\s*(?<value>\S+)/, "\\k<param> -> xxxxx").gsub(/EnvironmentVariable\((?<param>[A-Z_]+)\s*\,\s*(?<value>\S+)\)/, "EnvironmentVariable\(\\k<param>,xxxxx\)")}
    </record>
  </match>

  # Handle tagging for syslog events, sending them as system logs
  <match systemlog.syslog.**>
    @type record_reformer
    @id set_logging_tag_syslog
    enable_ruby true
    tag ${if not ENV['FLUENTD_SYSTEM_LOG_TYPE'].nil?; if ENV['FLUENTD_SYSTEM_LOG_TYPE'].to_s == "splunk"; ENV['FLUENTD_SYSTEM_LOG_SPLUNK_VOLUME'].to_s == "low" ? ( "systemlog.splunk.low" ) : ( "systemlog.splunk.high" ); elsif ENV['FLUENTD_SYSTEM_LOG_TYPE'].to_s == "sumologic"; "systemlog.sumologic." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_SOURCENAME'].to_s + "." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_SOURCECATEGORY'].to_s + "." + ENV['FLUENTD_SYSTEM_LOG_SUMOLOGIC_COLLECTORURL'].to_s; end; else "logging.disabled"; end}
  </match>

  # Handle tagging for Mesos executor logs, sending them as system logs
  <match executorlog>
    @type record_reformer
    @id set_logging_tag_executorlog
    enable_ruby true
    auto_typecast true
    tag ${if not ENV['FLUENTD_MESOS_LOG_TYPE'].nil?; if ENV['FLUENTD_MESOS_LOG_TYPE'].to_s == "splunk"; ENV['FLUENTD_MESOS_LOG_SPLUNK_VOLUME'].to_s == "low" ? ( "executorlog.splunk.low"  ) : ( "executorlog.splunk.high" ); elsif ENV['FLUENTD_MESOS_LOG_TYPE'].to_s == "sumologic"; "executorlog.sumologic." + ENV['FLUENTD_MESOS_LOG_SUMOLOGIC_SOURCENAME'].to_s + "." + ENV['FLUENTD_MESOS_LOG_SUMOLOGIC_SOURCECATEGORY'].to_s + "." + ENV['FLUENTD_MESOS_LOG_SUMOLOGIC_COLLECTORURL'].to_s; end; else "logging.disabled"; end}
    <record>
      host ${record['source_host']}
      message ${record['message'].to_s.gsub(/((?:(?:4\d{3})|(?:5[1-5]\d{2})|6(?:011|5[0-9]{2}))(?:-?|\040?)(?:\d{4}(?:-?|\040?)){3}|(?:3[4,7]\d{2})(?:-?|\040?)\d{6}(?:-?|\040?)\d{5})/, "<POSSIBLE_CREDIT_CARD_NUMBER>").gsub(/\s*-e\s+(?<param>\w+)=(?<value>\S+)/, " -e \\k<param>=xxxxx").gsub(/(?<param>[A-Z_]+)\s*->\s*(?<value>\S+)/, "\\k<param> -> xxxxx").gsub(/EnvironmentVariable\((?<param>[A-Z_]+)\s*\,\s*(?<value>\S+)\)/, "EnvironmentVariable\(\\k<param>,xxxxx\)")}
      source ${record['file_path'].split('/')[10]}
    </record>
  </match>

  # Discard logs that don't have a sender configured (splunk, sumologic, etc.)
  <match logging.disabled>
    @type null
  </match>

  <match applog.splunk.high>
    @type copy
    <store>
      @type splunk-http-eventcollector
      @id applog_to_splunk
      server "#{ENV['FLUENTD_SPLUNK_HEC_SERVER']}"
      verify "#{ENV['FLUENTD_SPLUNK_HEC_SSL_VERIFY']}"
      token "#{ENV['FLUENTD_SPLUNK_HEC_TOKEN']}"
      time_key "#{ENV['FLUENTD_SPLUNK_HEC_TIME_KEY']}"
      all_items "#{ENV['FLUENTD_SPLUNK_HEC_ALL_ITEMS']}"
      post_retry_max "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_MAX']}"
      post_retry_interval "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_INTERVAL']}"
      protocol "#{ENV['FLUENTD_SPLUNK_HEC_PROTOCOL']}"
      batch_size_limit "#{ENV['FLUENTD_SPLUNK_HEC_BATCH_SIZE_LIMIT']}"
      coerce_to_utf8 "#{ENV['FLUENTD_SPLUNK_HEC_COERCE_TO_UTF8']}"
      non_utf8_replacement_string "#{ENV['FLUENTD_SPLUNK_HEC_NON_UTF8_REPLACEMENT_STRING']}"

      buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
      buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/1/applog.splunk.high/"
      buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
      buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
      flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
      flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
      retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_WAIT']}"
      max_retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_MAX_RETRY_WAIT']}"
      retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
      disable_retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_DISABLE_RETRY_LIMIT']}"
      num_threads "#{ENV['FLUENTD_SPLUNK_HEC_NUM_THREADS']}"

      host ${record["host"]}
      index ${record["index"]}
      source ${record["source"]}
      sourcetype ${record["sourcetype"]}
      <secondary>
        @type s3
        s3_bucket "#{ENV['FLUENTD_AWS_S3_BUCKET']}"
        s3_region us-east-1
        path "#{ENV['FLUENTD_AWS_S3_BUCKET_PATH']}"
        s3_object_key_format "%{path}collector/1/applog/splunk/high/#{ENV['HOST']}_%{time_slice}_%{index}.%{file_extension}"
        store_as text
        buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
        buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/1/s3/applog.splunk.high/"
        buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
        buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
        flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
        flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
        retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
        <assume_role_credentials>
         role_arn "#{ENV['FLUENTD_AWS_IAM_ROLE']}"
         role_session_name fluentd-s3
        </assume_role_credentials>
      </secondary>
    </store>
    <store>
      @type flowcounter
      @id applog_high_metrics
      @label @counts
      tag fluentd.apploghigh.metrics
      aggregate all
      count_keys *
      unit minute
    </store>
  </match>

  <match applog.splunk.low>
    @type copy
    <store>
      @type splunk-http-eventcollector
      @id applog_to_lvc_splunk
      server "#{ENV['FLUENTD_SPLUNK_HEC_LVC_SERVER']}"
      verify "#{ENV['FLUENTD_SPLUNK_HEC_LVC_SSL_VERIFY']}"
      token "#{ENV['FLUENTD_SPLUNK_HEC_LVC_TOKEN']}"
      time_key "#{ENV['FLUENTD_SPLUNK_HEC_TIME_KEY']}"
      all_items "#{ENV['FLUENTD_SPLUNK_HEC_ALL_ITEMS']}"
      post_retry_max "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_MAX']}"
      post_retry_interval "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_INTERVAL']}"
      protocol "#{ENV['FLUENTD_SPLUNK_HEC_LVC_PROTOCOL']}"
      batch_size_limit "#{ENV['FLUENTD_SPLUNK_HEC_BATCH_SIZE_LIMIT']}"
      coerce_to_utf8 "#{ENV['FLUENTD_SPLUNK_HEC_COERCE_TO_UTF8']}"
      non_utf8_replacement_string "#{ENV['FLUENTD_SPLUNK_HEC_NON_UTF8_REPLACEMENT_STRING']}"

      buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
      buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/1/applog.splunk.low/"
      buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
      buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
      flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
      flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
      retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_WAIT']}"
      max_retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_MAX_RETRY_WAIT']}"
      retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
      disable_retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_DISABLE_RETRY_LIMIT']}"
      num_threads "#{ENV['FLUENTD_SPLUNK_HEC_NUM_THREADS']}"

      host ${record["host"]}
      index ${record["index"]}
      source ${record["source"]}
      sourcetype ${record["sourcetype"]}
      <secondary>
        @type s3
        s3_bucket "#{ENV['FLUENTD_AWS_S3_BUCKET']}"
        s3_region us-east-1
        path "#{ENV['FLUENTD_AWS_S3_BUCKET_PATH']}"
        s3_object_key_format "%{path}collector/1/applog/splunk/low/#{ENV['HOST']}_%{time_slice}_%{index}.%{file_extension}"
        store_as text
        buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
        buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/1/s3/applog.splunk.low/"
        buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
        buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
        flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
        flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
        retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
        <assume_role_credentials>
         role_arn "#{ENV['FLUENTD_AWS_IAM_ROLE']}"
         role_session_name fluentd-s3
        </assume_role_credentials>
      </secondary>
    </store>
    <store>
      @type flowcounter
      @id applog_metrics
      @label @counts
      tag fluentd.apploglow.metrics
      aggregate all
      count_keys *
      unit minute
    </store>
  </match>

  <match systemlog.splunk.*>
    @type copy
    <store>
      @type splunk-http-eventcollector
      @id systemlog_to_splunk
      server "#{ENV['FLUENTD_SPLUNK_HEC_SERVER']}"
      verify "#{ENV['FLUENTD_SPLUNK_HEC_SSL_VERIFY']}"
      token "#{ENV['FLUENTD_SPLUNK_HEC_TOKEN']}"
      time_key "#{ENV['FLUENTD_SPLUNK_HEC_TIME_KEY']}"
      all_items "#{ENV['FLUENTD_SPLUNK_HEC_ALL_ITEMS']}"
      post_retry_max "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_MAX']}"
      post_retry_interval "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_INTERVAL']}"
      protocol "#{ENV['FLUENTD_SPLUNK_HEC_PROTOCOL']}"
      batch_size_limit "#{ENV['FLUENTD_SPLUNK_HEC_BATCH_SIZE_LIMIT']}"
      coerce_to_utf8 "#{ENV['FLUENTD_SPLUNK_HEC_COERCE_TO_UTF8']}"
      non_utf8_replacement_string "#{ENV['FLUENTD_SPLUNK_HEC_NON_UTF8_REPLACEMENT_STRING']}"

      buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
      buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/1/systemlog.splunk/"
      buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
      buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
      flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
      flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
      retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_WAIT']}"
      max_retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_MAX_RETRY_WAIT']}"
      retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
      disable_retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_DISABLE_RETRY_LIMIT']}"
      num_threads "#{ENV['FLUENTD_SPLUNK_HEC_NUM_THREADS']}"

      host ${record["host"]}
      index "#{ENV['FLUENTD_SYSTEM_LOG_SPLUNK_INDEX']}"
      source ${record["source"]}
      sourcetype "#{ENV['FLUENTD_SYSTEM_LOG_SPLUNK_SOURCETYPE']}"
      <secondary>
        @type s3
        s3_bucket "#{ENV['FLUENTD_AWS_S3_BUCKET']}"
        s3_region us-east-1
        path "#{ENV['FLUENTD_AWS_S3_BUCKET_PATH']}"
        s3_object_key_format "%{path}collector/1/systemlog/#{ENV['HOST']}_%{time_slice}_%{index}.%{file_extension}"
        store_as text
        buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
        buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/1/s3/systemlog.splunk/"
        buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
        buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
        flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
        flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
        retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
        <assume_role_credentials>
         role_arn "#{ENV['FLUENTD_AWS_IAM_ROLE']}"
         role_session_name fluentd-s3
        </assume_role_credentials>
      </secondary>
    </store>
    <store>
      @type flowcounter
      @id systemlog_metrics
      @label @counts
      tag fluentd.systemlog.metrics
      aggregate all
      count_keys message
      unit minute
    </store>
  </match>

  <match executorlog.splunk.*>
    @type copy
    <store>
      @type splunk-http-eventcollector
      @id executorlog_to_splunk
      server "#{ENV['FLUENTD_SPLUNK_HEC_SERVER']}"
      verify "#{ENV['FLUENTD_SPLUNK_HEC_SSL_VERIFY']}"
      token "#{ENV['FLUENTD_SPLUNK_HEC_TOKEN']}"
      time_key "#{ENV['FLUENTD_SPLUNK_HEC_TIME_KEY']}"
      all_items "#{ENV['FLUENTD_SPLUNK_HEC_ALL_ITEMS']}"
      post_retry_max "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_MAX']}"
      post_retry_interval "#{ENV['FLUENTD_SPLUNK_HEC_POST_RETRY_INTERVAL']}"
      protocol "#{ENV['FLUENTD_SPLUNK_HEC_PROTOCOL']}"
      batch_size_limit "#{ENV['FLUENTD_SPLUNK_HEC_BATCH_SIZE_LIMIT']}"
      coerce_to_utf8 "#{ENV['FLUENTD_SPLUNK_HEC_COERCE_TO_UTF8']}"
      non_utf8_replacement_string "#{ENV['FLUENTD_SPLUNK_HEC_NON_UTF8_REPLACEMENT_STRING']}"

      buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
      buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/1/executorlog.splunk/"
      buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
      buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
      flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
      flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
      retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_WAIT']}"
      max_retry_wait "#{ENV['FLUENTD_SPLUNK_HEC_MAX_RETRY_WAIT']}"
      retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
      disable_retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_DISABLE_RETRY_LIMIT']}"
      num_threads "#{ENV['FLUENTD_SPLUNK_HEC_NUM_THREADS']}"

      host ${record["host"]}
      index "#{ENV['FLUENTD_MESOS_LOG_SPLUNK_INDEX']}"
      source ${record["source"]}
      sourcetype "#{ENV['FLUENTD_MESOS_LOG_SPLUNK_SOURCETYPE']}"
      <secondary>
        @type s3
        s3_bucket "#{ENV['FLUENTD_AWS_S3_BUCKET']}"
        s3_region us-east-1
        path "#{ENV['FLUENTD_AWS_S3_BUCKET_PATH']}"
        s3_object_key_format "%{path}collector/1/executorlog/#{ENV['HOST']}_%{time_slice}_%{index}.%{file_extension}"
        store_as text
        buffer_type "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_TYPE']}"
        buffer_path "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_PATH']}/1/s3/executorlog.splunk/"
        buffer_queue_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_QUEUE_LIMIT']}"
        buffer_chunk_limit "#{ENV['FLUENTD_SPLUNK_HEC_BUFFER_CHUNK_LIMIT']}"
        flush_interval "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_INTERVAL']}"
        flush_at_shutdown "#{ENV['FLUENTD_SPLUNK_HEC_FLUSH_AT_SHUTDOWN']}"
        retry_limit "#{ENV['FLUENTD_SPLUNK_HEC_RETRY_LIMIT']}"
        <assume_role_credentials>
         role_arn "#{ENV['FLUENTD_AWS_IAM_ROLE']}"
         role_session_name fluentd-s3
        </assume_role_credentials>
      </secondary>
    </store>
    <store>
      @type flowcounter
      @id executorlog_metrics
      @label @counts
      tag fluentd.executorlog.metrics
      aggregate all
      count_keys message
      unit minute
    </store>
  </match>

</label>

<label @counts>
  <match fluentd.*.metrics>
    @type stdout
  </match>
</label>
